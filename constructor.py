#    /$$$$$$$$ /$$$$$$$   /$$$$$$  /$$$$$$$        /$$$$$$$$ /$$$$$$   /$$$$$$  /$$         #
#   |__  $$__/| $$__  $$ /$$__  $$| $$__  $$      |__  $$__//$$__  $$ /$$__  $$| $$         #
#      | $$   | $$  \ $$| $$  \ $$| $$  \ $$         | $$  | $$  \ $$| $$  \ $$| $$         #
#      | $$   | $$$$$$$/| $$$$$$$$| $$$$$$$/         | $$  | $$  | $$| $$  | $$| $$         #
#      | $$   | $$__  $$| $$__  $$| $$____/          | $$  | $$  | $$| $$  | $$| $$         #
#      | $$   | $$  \ $$| $$  | $$| $$               | $$  | $$  | $$| $$  | $$| $$         #
#      | $$   | $$  | $$| $$  | $$| $$               | $$  |  $$$$$$/|  $$$$$$/| $$$$$$$$   #
#      |__/   |__/  |__/|__/  |__/|__/               |__/   \______/  \______/ |________/   #

### TRAP debug tool designed for IoT project course [Prof. Brunelli Davide,               ###
### Prof. Fontanelli Davide, PhD. Alessandro Torrisi] and                                 ###
### designed by Matteo Spadetto [214352]                                                  ###
### This sys is intended as a dbg tool for the TRAP research of Embedded sys lab in UniTn ###
###                                                                                       ###
### The tool (using Node_RED, Grafana, InfluxDB, Python and a Linux bash file) reads the  ###
### data from uart that several devices, which are communicating between eachothers,      ###
### sends to the broker. The goal is not only to debug the system but also to do it with  ###
### an high level of scalability. For this reason the Node_RED nodes, the InfluxDB        ###
### (database, measurements and fields) and the Grafana rows/tables are automatically     ###
### generated by this Python script. After the setup the system runs in online mode       ###
### and it is possible to see the data collected by the uart on Grafana in graphs and     ###
### more user-friendly HMI. In Node-RED is also possible to download the csv files from   ###
### the InfluxDB database (one file for each measurement)                                 ###
                                                                                     
from os import supports_effective_ids
import sys
import re
from datetime import datetime
from typing import final

# DOWN for more settings in MAIN and PASS as ARGS the port to which the device are connected

### DEF: used to split the files using '!' as separator into array string elements

def custom_split(file, separator):
    with open(file) as row_file:
        str = row_file.read()
    results = []
    temp = ''
    i = 0
    for char in str:
        if(char == separator):
            results.append(temp)
            #print(results[i])
            i = i + 1
            temp = ''
        else:
            temp = temp + char
    return results

### DEF: used to build a grafana row for each device in Grafana [str file, str separator, str y_position, str row_id, str row_title]
    # File of the stock Grafana template and as separator '!' is used as not used by neither Grafana and Node-RED
    # The title and id are relative to the device: first device --> title = Device_0 || id = 100 + 10 * n_th device
    # The y_position is calcultate by the default h/w of each row and table times the n_th device

def row_build(file, separator, y, id, title):
    results = custom_split(file, separator)
    final_str = results[0] + '\n\t"y": ' + y +  results[2] + '\n\t"id": ' + id + ',' + '\n\t\"title": "' + title + '",' + results[5]
    return final_str

### DEF: build each table of the row in Grafana [str file, str separator, str y_position, str table_id, str db_field, str title]
    # File of the stock Grafana template and as separator '!' is used as not used by neither Grafana and Node-RED
    # The title and id are relative to the device: first device --> title = tx_done_0 || id = 101 + 10 * n_th device
    # The title and id are relative to the device: first device --> title = rx_done_0 || id = 102 + 10 * n_th device
    # The field is the one of the InfluxDB to visualize in the table itself

def table_build(file, separator, y, id, field, title):
    results = custom_split(file, separator)
    final_str = results[0] + '\n\t"y": ' + y + results[2] + '\n\t"id":' + id + ',' + results[4] + '\n\t"' + field + '"' + results[6] + '\n\t\"title": "' + title + '",' + results[8]
    return final_str

### DEF: build each node serial option [str file, str separator, str serial_id, str uart_port, str port_baudrate]
    # File of the stock Grafana template and as separator '!' is used as not used by neither Grafana and Node-RED
    # Block with the uart device option to link to the the relative serial node of Node_RED
    # The serial_id is the one linking the option with the relative serial node si they must be the same

def node_opt_mod(file, separator, serial_id, port, baud):
    results = custom_split(file, separator)
    final_str = results[0] + '\n\t"id": "' + serial_id + '",' + results[2] + '\n\t"serialport": "' + port + '",' + '\n\t"serialbaud": "' + baud + '",' + results[5]
    return final_str
    
### DEF: build each serial node [str file, str separator, str id, str serial_id, str name, str wire]
    # File of the stock Grafana template and as separator '!' is used as not used by neither Grafana and Node-RED
    # Block with the uart device linking to the the relative serial option node of Node_RED
    # The id is the one of the serial node (not relevant)
    # The serial_id is the one linking the serial_node to its options so it must be the same of its option node
    # The name is related to the device connected and the wire is the connection to the function node so it must be the same of its id 

def node_uart(file, separator, id, serial_id, name, wire, dev_id):
    results = custom_split(file, separator)
    final_str = results[0] + '\n\t"id": "' + id + '",' + results[2] + '\n\t"name": "' + name + '",' + '\n\t"serial": "' + serial_id + '",' + results[5]  + '\n\t"y": ' + str(500 + (50 * dev_id)) + ',' + results[7] + '\n\t"' + wire + '"' + results[9]
    return final_str

### DEF: build each function node [str file, str separator, str id, str str_id]
    # File of the stock Grafana template and as separator '!' is used as not used by neither Grafana and Node-RED
    # Block with the uart device option to link to the the relative serial node of Node_RED
    # The id must be the same of the wire parameter of the relative serial node to receive data
    # The str_id string is the custom label for the storage fields relative to that device in InfluxDB 
    #The fields must match between the one set in Node_RED and in Grafana for the particulare device
    
def node_func(file, separator, id, str_id, dev_id):
    results = custom_split(file, separator)
    final_str = results[0] + '\n\t"id": "' + id + '",' + results[2] + str_id + results[4] + '\n\t"y": ' + str(500 + (50 * dev_id)) + ',' +results[6]
    return final_str

### DEF: create the Grafana device passing just the [int dev_num] number of the n-th device: Device_0 --> dev_num = 0
    # The IDs of each row and table starts from 100 to avoid collisions with pre-created table built in Grafana
    # The function build a row, one graph and 6 singlestat for each device
    # The total singlestat are pre-ceated in Grafana and there are not need to modify them
    # The dev_num must be >= 0
    # It returns the string to build an entire row with its table aka a device

def new_device_grafana(dev_num):
    if((dev_num >= 0)):
        dev_first_id = 100 + (dev_num * 10)
        test_row = row_build('grafana_templates/grafana_custom_row.txt', '!', str(dev_num * 10 + 14), str(dev_first_id), 'Device_' + str(dev_num))
        #print(test_row)
        test_graph = table_build('grafana_templates/grafana_custom_graph.txt', '!', str(dev_num * 10 + 15), str(dev_first_id + 1), 'engy_' + str(dev_num), 'Energy level [%]')
        #print(test_graph)
        test_tx_done = table_build('grafana_templates/grafana_custom_tx_done.txt', '!', str(dev_num * 10 + 15), str(dev_first_id + 2), 'tx_done_' + str(dev_num), 'tx_done')
        #print(test_tx_done)
        test_rx_done = table_build('grafana_templates/grafana_custom_rx_done.txt', '!', str(dev_num * 10 + 15), str(dev_first_id + 3), 'rx_done_' + str(dev_num), 'rx_done')
        #print(test_rx_done)
        test_tx_wait = table_build('grafana_templates/grafana_custom_tx_wait.txt', '!', str(dev_num * 10 + 18), str(dev_first_id + 4), 'tx_wait_' + str(dev_num), 'tx_wait')
        #print(test_tx_wait)
        test_rx_fail = table_build('grafana_templates/grafana_custom_rx_fail.txt', '!', str(dev_num * 10 + 18), str(dev_first_id + 5), 'rx_fail_' + str(dev_num), 'rx_fail')
        #print(test_rx_fail)
        test_burst = table_build('grafana_templates/grafana_custom_burst.txt', '!', str(dev_num * 10 + 21), str(dev_first_id + 6), 'burst_' + str(dev_num), 'burst')
        #print(test_burst)
        test_dbg = table_build('grafana_templates/grafana_custom_dbg.txt', '!', str(dev_num * 10 + 21), str(dev_first_id + 7), 'dbg_' + str(dev_num), 'dbg')
        #print(test_dbg)
        device_str = test_row + test_graph + test_tx_done + test_rx_done + test_tx_wait + test_rx_fail + test_burst + test_dbg
        return device_str
    else:
        print('[Error] --> Wrong dev_num')
        sys.exit()

### DEF: create the Node_RED device using [str serial_name, str func_id, serial_id, opt_serial_id, str_id, port, baud]
    # Everything is set later automatically by software but not port and baud which need to be specified as uart_port_path (later)
    # If after importing the nodes uart and function are not displayed just drag and drop them (due to the not controlled graphic node position)
    # It returns the string to build a node uart with its function wired to the main Node_RED function

def new_device_node(dev_id, serial_name, func_id, serial_id, opt_serial_id, str_id, port, baud):
    test_uart_opt = node_opt_mod('node_templates/node_uart_opt.txt', '!', opt_serial_id, port, baud)
    #print(test_uart_opt)
    test_uart = node_uart('node_templates/node_uart.txt', '!', serial_id, opt_serial_id, serial_name, func_id, dev_id)
    #print(test_uart)
    test_func = node_func('node_templates/node_func.txt', '!', func_id, str_id, dev_id)
    #print(test_func)
    device_str = test_func + test_uart + test_uart_opt
    return device_str

### DEF: create the new device both in Node_RED and Grafana linking the fields, rows, tables and uart_ports
    # It returns the strings to add to the Node_RED and Grafana template '.json' file

def new_device(dev_id, port, baud):
    dev_out_str = []
    grafana_dev_str= new_device_grafana(dev_id)
    str_id = '\\"burst_' + str(dev_id) + '\\", \\"tx_done_' + str(dev_id) + '\\", \\"rx_done_' + str(dev_id) + '\\", \\"rx_fail_' + str(dev_id) + '\\", \\"tx_wait_' + str(dev_id) + '\\", \\"dbg_' + str(dev_id) + '\\", \\"engy_' + str(dev_id) + '\\"'
    node_dev_str = new_device_node(dev_id, 'dev_' + str(dev_id), str(dev_id * 3) + '.' + str(dev_id * 3), str((dev_id * 3) + 1) + '.' + str((dev_id * 3) + 1), str((dev_id * 3) + 2) + '.' + str((dev_id * 3) + 2), str_id, port, baud)
    dev_out_str.append(grafana_dev_str)
    dev_out_str.append(node_dev_str)
    return dev_out_str


### MAIN to add multiple devices to both Node_RED and Grafana ###

CBLUE = '\33[1m\033[44m'
CVIOLET = '\33[1m\033[35m'
CGREEEN = '\33[1m\033[32m'
CEND = '\033[0m'

uart_port_path = []       # All the ports to which a device is connected
limit = 1
print(CBLUE + '[TRAP_TOOL]' + CEND + ' Selected uart ports are:')
while (limit < len(sys.argv)):
    uart_port_path.append(sys.argv[limit])
    print('\t\t- ' + sys.argv[limit])
    limit = limit + 1

BAUD = '115200'                         # The common baudrate
SET_DEV_NUM = len(uart_port_path)       # The number of peripheral connected

grafana_final_add = ''                  # Final string to add to the Grafana template '.json' file 
node_final_add = ''                     # Final string to add to the Node_RED template '.json' file
placer = 0

print(CBLUE + '[TRAP_TOOL]' + CEND + ' Entering creation mode\t\t\t\t\t' + CVIOLET + ' [DONE]' + CEND)

while (placer < SET_DEV_NUM):                                                                                                       # Cycling for all the devices to add
    print(CBLUE + '[TRAP_TOOL]' + CEND + ' Entering creation of DEVICE_' + str(placer))
    dev_str = new_device(placer, uart_port_path[placer], BAUD)                                                                      # Add a new device
    grafana_final_add = grafana_final_add + dev_str[0]                                                                              # Compose Grafana string
    print(CBLUE + '[TRAP_TOOL]' + CEND + ' Grafana creation of DEVICE_' + str(placer) + '\t\t\t\t' + CVIOLET + ' [DONE]' + CEND)
    node_final_add = node_final_add + dev_str[1]                                                                                    # Compose Node_RED string
    print(CBLUE + '[TRAP_TOOL]' + CEND + ' Node_RED creation of DEVICE_' + str(placer) + '\t\t\t\t' + CVIOLET + ' [DONE]' + CEND)
    placer = placer + 1                     

print(CBLUE + '[TRAP_TOOL]' + CEND + ' All device components were generated\t\t\t' + CVIOLET + ' [DONE]' + CEND)

### Add the custom string to Grafana template ###

test_grafana_stock = custom_split('grafana_templates/grafana_stock.txt', '!')     # Split the Grafana template to add the custom strings
now = datetime.now()                                            
dashboard = now.strftime("%d/%m/%Y_%H:%M:%S")                   # Use date and time to name the  Grafana dashboard
grafana_uid = "IoT2021TRAP"                                     # Uid for Grafana dashboard (if multiple import just changed it to not overwrite)
grafana_final_str = test_grafana_stock[0] + grafana_final_add + test_grafana_stock[1] + '\n\t"title": "Iot_TRAP_' + dashboard + '",\n\t"grafana_uid": "' + grafana_uid + '",' + test_grafana_stock[3]
#print(final_str)
grafana_str_file = "use_grafana.json"
grafana_out_file = open(grafana_str_file, "w")           # Open Grafana '.json' file
grafana_out_file.write(grafana_final_str)                # Write all to Grafana '.json' file
grafana_out_file.close()                                 # Close Grafana '.json' file

print(CBLUE + '[TRAP_TOOL]' + CEND + ' Grafana .json file wrote and saved as: ' + grafana_str_file + '\t' + CVIOLET + ' [DONE]' + CEND)

### Add the custom string to Node_RED template ###

test_node_stock = custom_split('node_templates/flow_stock.txt', '!')            # Split the Node_RED template to add the custom strings
flow = 'IoT_TRAP_tool'                                                          # Flow Node_RED name
node_uid = '4440423b.0c7bcc'                                                    # Uid for Node_RED flow
node_final_str = test_node_stock[0] + '\n\t"id": "' + node_uid + '",' + test_node_stock[2] + '\n\t"label": "' + flow + '",' + test_node_stock[4] + node_final_add + test_node_stock[5]
#print(node_final_str)
node_str_file = "use_node.json"
node_out_file = open(node_str_file, "w")                                        # Open Node_RED '.json' file
node_out_file.write(node_final_str)                                             # Write all to Node_RED '.json' file
node_out_file.close()                                                           # Close Node_RED '.json' file

print(CBLUE + '[TRAP_TOOL]' + CEND + ' Node_RED .json file wrote and saved as: ' + node_str_file + '\t' + CVIOLET + ' [DONE]' + CEND)
print(CBLUE + '[TRAP_TOOL]' + CEND + ' File wrote and saved with params:\n\t\t- grafana_uid = ' + grafana_uid + '\n\t\t- grafana_dash = IoT_TRAP_' + dashboard + '\n\t\t- node_uid = ' + flow + '\n\t\t- node_flow = ' + node_uid + CGREEEN + '\n[TRAP_TOOL] Everything done\t\t\t\t\t\t[DONE ALL]' + CEND)